<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql事务,关于事务的ACID性质</title>
      <link href="/2022/12/07/mysql%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/12/07/mysql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><h3 id="1-事务定义"><a href="#1-事务定义" class="headerlink" title="1.事务定义"></a>1.事务定义</h3><p><strong>事务：</strong>事务(Transaction)是一个最小的不可在分的工作单元;通常一个事务对应一个完整的业务(例如银行账户转账业务,该业务是一个最小的工作单元)<br>一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成.<br>事务只和DML语句有关,或者说DML语句才有事务.这个和业务逻辑有关,业务逻辑不同,DML语句的个数不同.</p><p>目前常用的存储引擎有InnoDB(MySQL5.5以后默认的存储引擎)和MyISAM(MySQL5.5之前默认的存储引擎),其中<strong>InnoDB支持事务处理机制，而MyISAM不支持</strong>.</p><h3 id="2-事务的四大特性-ACID"><a href="#2-事务的四大特性-ACID" class="headerlink" title="2.事务的四大特性(ACID)"></a>2.事务的四大特性(ACID)</h3><p>事务有四个特性：<strong>原子性</strong>(Atomicity)、<strong>一致性</strong>(Consistency)、<strong>隔离性</strong>(Isolation)和<strong>持久性</strong>(Durability)</p><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性:"></a>1.原子性:</h4><p>事务中的所有操作可以看做一个原子,事务是应用中不可再分的最小的逻辑执行体.</p><p>使用事务对数据进行修改的操作序列,要么全部执行,要么全不执行.</p><h4 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2.一致性:"></a>2.一致性:</h4><p>一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。</p><h4 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3.隔离性:"></a>3.隔离性:</h4><p>隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。</p><h4 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4.持久性:"></a>4.持久性:</h4><p>持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。</p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi4saa70j30m20e2756.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi4saa70j30m20e2756.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221207221439271" style="zoom:50%;" /><blockquote><p>事务acid特性的实现主要依赖各种log(日志)和锁</p><p>其中原子性依赖undolog,隔离性依赖锁,持久性依赖redolog</p><p>原子性,隔离性和持久性共同实现了事务的一致性</p></blockquote><h3 id="3-日志"><a href="#3-日志" class="headerlink" title="3.日志"></a>3.日志</h3><p>MySQL 中有七种日志文件,分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）.</p><h4 id="日志的几个知识点"><a href="#日志的几个知识点" class="headerlink" title="日志的几个知识点"></a>日志的几个知识点</h4><h5 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1.binlog"></a>1.binlog</h5><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><blockquote><p><strong>复制：</strong>MySQL 主从复制在 Master 端开启 binlog，Master 把它的二进制日志传递给 slaves 并回放来达到 master-slave 数据一致的目的</p><p><strong>数据恢复：</strong>通过 mysqlbinlog 工具恢复数据</p><p>binlog 不会记录不修改数据的语句，比如Select或者Show</p><p>binlog 会重写日志中的密码，保证不以纯文本的形式出现MySQL 8 之后的版本可以选择对 binlog 进行加密</p><p><strong>具体的写入时间：</strong>在事务提交的时候,数据库会把 binlog cache 写入 binlog 文件中,但并没有执行fsync()操作,即只将文件内容写入到 OS 缓存中.随后根据配置判断是否执行 fsync().</p><p><strong>删除时间：</strong>保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p></blockquote><h6 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h6><p>binlog 日志有三种格式，分别为 <strong>STATMENT 、 ROW</strong> 和 <strong>MIXED</strong>。</p><blockquote><p><strong>STATMENT：</strong><strong><strong>基于SQL 语句的复制</strong></strong>( statement-based replication, SBR )，每一条会修改数据的sql语句会记录到binlog 中 。</p><p>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO , 从而提高了性能；<br>缺点：主从复制时，存在部分函数（如 sleep）及存储过程在 slave 上会出现与 master 结果不一致的情况。<br><strong>ROW：****基于行的复制</strong>(row-based replication, RBR )，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。</p><p>优点：因此不会发生某些特定情况下的存储过程、函数或者触发器的调用触发无法被正确复制的问题。<br>缺点：会产生大量的日志，尤其是alter table 的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中，实际等于重建了表。<br>*<em>MIXED：</em>***基于STATMENT 和 ROW 两种模式的混合复制(**mixed-based replication, MBR )，一般的复制使用STATEMENT 模式保存 binlog ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 binlog。</p></blockquote><h6 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h6><p>复制是 MySQL 最重要的功能之一，MySQL 集群的高可用、负载均衡和读写分离都是基于复制来实现。复制步骤如下：</p><blockquote><p>1.Master 将数据改变记录到二进制日志(binary log)中。</p><p>2.Slave 上面的 IO 进程连接上 Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。</p><p>3.Master 接收到来自 Slave 的 IO 进程的请求后，负责复制的 IO 进程会根据请求信息读取日志指定位置之后的日志信息，返回给 Slave 的 IO 进程。返回信息中<strong>除了日志所包含的信息之外，还包括本次返回的信息已经到 Master 端的 binlog 文件的名称以及 binlog 的位置</strong>。</p><p>4.Slave 的 IO 进程接收到信息后，将接收到的日志内容依次添加到 <strong>Slave 端的 relaylog 文件的最末端</strong>，并将读取到的 Master 端的 binlog 的文件名和位置记录到 masterinfo 文件中，以便在下一次读取的时候能够清楚的告诉 Master 从某个 binlog 的哪个位置开始往后的日志内容。</p><p>5.Slave 的 SQL 进程检测到 relaylog 中新增加了内容后，会马上<strong>解析 relaylog</strong> 的内容成为在 Master 端真实执行时候的那些可执行的内容，并在自身执行。</p></blockquote><h5 id="2-redolog"><a href="#2-redolog" class="headerlink" title="2.redolog"></a>2.redolog</h5><p>redolog 包括两部分：一个是内存中的日志缓冲( redolog buffer ),另一个是磁盘上的日志文件( redologfile).</p><p>mysql 每执行一条 DML 语句,先将记录写入 redolog buffer,后续某个时间点再一次性将多个操作记录写到 redolog file.这种 先写日志,再写磁盘 的技术就是 MySQL里经常说到的 WAL(Write-Ahead Logging) 技术。</p><blockquote><p>1.事务提交后不需要每一次都把数据写入磁盘中，<strong>先写到redolog日志中，然后写入磁盘</strong>。</p><p>2.redolog 和写表的区别就在于随机写和顺序写。MySQL 的表数据是随机存储在磁盘中的，而 redolog 是一块固定大小的连续空间。而磁盘顺序写入要比随机写入快几个数量级。</p></blockquote><p>mysql 支持三种将 redo log buffer 写入 redo log file 的时机,<strong>延迟写</strong>、<strong>实时写实时刷</strong>、<strong>实时写延迟刷</strong></p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi51vmq8j30ui0i4414.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi51vmq8j30ui0i4414.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221207230411033" style="zoom: 45%;" /><h5 id="3-undolog"><a href="#3-undolog" class="headerlink" title="3.undolog"></a>3.undolog</h5><p>事务的原子性底层就是通过 undolog 实现的,undo log主要记录了数据的逻辑变化,比如一条 INSERT 语句,对应一条DELETE 的 undolog ,对于每个 UPDATE 语句,对应一条相反的 UPDATE 的 undolog ,这样在发生错误时,就能回滚到事务之前的数据状态.同时，,undolog 也是 MVCC(多版本并发控制)实现的关键.</p><h6 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h6><ol><li>事务1:当我门新增一条记录,mysql在基本表后面自动生成隐藏字段(trx_id&#x3D;1,roll_ptr&#x3D;null,row_id&#x3D;1),如图</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi55zq2bj312q05gwfe.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi55zq2bj312q05gwfe.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ol start="2"><li><p>事务2:对表name字段修改,生成undolog,新记录的roll_ptr的值是undolog头节点位置,最新记录和undolog之间用版本链链接,如图</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi59rem2j314y0eutaw.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi59rem2j314y0eutaw.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208132124873"></p></li><li><p>事务3:修改age字段,结果如图</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5dfy66j316k0m2adj.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5dfy66j316k0m2adj.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208132517933"></p></li></ol><p>通过上述的图示，我们发现undolog最终会变成一个链表，链首表示的是最新的旧纪录，链尾表示的是最旧的旧纪录，undolog链表<strong>不会无限增加</strong>，后台会有一个<strong>purge</strong>的线程来对undo log进行维护，当不需要的时候会进行删除，在undolog删除的时候会分为两类，insert对应一类undolog，只要事务提交就可以删除，update、delete对应一类undolog，除了事务提交之外，还要保证mvcc不用才会删除</p><h5 id="4-errorlog"><a href="#4-errorlog" class="headerlink" title="4.errorlog"></a>4.errorlog</h5><p>用来记录 MySQL 服务器运行过程中的错误信息,默认开启无法关闭.<br>复制环境下，从服务器进程的信息也会被记录进错误日志</p><h5 id="5-slowlog"><a href="#5-slowlog" class="headerlink" title="5.slowlog"></a>5.slowlog</h5><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的SQL语句，具体是指运行时间超过 long_query_time 值的SQL，这样的SQL则会被记录到慢查询日志中。long_query_time 的默认值为10，意思是运行10S以上的SQL语句。</p><p>默认情况下，MySQL数据库并没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。<br>慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表.</p><h5 id="6-relaylog"><a href="#6-relaylog" class="headerlink" title="6.relaylog"></a>6.relaylog</h5><p>中继日志用于主从复制架构中的从服务器上，从服务器的 slave 进程从主服务器处获取二进制日志的内容并写入中继日志，然后由 IO 进程读取并执行中继日志中的语句.</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5ihwtcj313g0gadhw.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5ihwtcj313g0gadhw.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221207231106295"></p><h3 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h3><p>全称multi-version Concurency control,多版本并发控制，是为了解决并发读写问题存在的MVCC的实现原理由三部分组件完成：隐藏字段，undolog，readview</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5mbgqjj30yu0gu773.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5mbgqjj30yu0gu773.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221207231657590"></p><h6 id="1-数据库并发有以下几种场景："><a href="#1-数据库并发有以下几种场景：" class="headerlink" title="1.数据库并发有以下几种场景："></a>1.<strong>数据库并发有以下几种场景：</strong></h6><blockquote><p>读-读：不存在任何问题。<br>读-写：有线程安全问题，可能出现脏读、幻读、不可重复读。<br>写-写：有线程安全问题，可能存在更新丢失等。</p></blockquote><p>mvcc解决的就是读写时的线程安全问题，线程不用去争抢读写锁。</p><blockquote><p>mvcc所提到的读是<strong>快照读</strong>，也就是普通的select语句。快照读在读写时不用加锁，不过可能会读到历史数据。</p><p>还有一种读取数据的方式是<strong>当前读</strong>，是一种悲观锁的操作。它会对当前读取的数据进行加锁，所以读到的数据都是最新的。主要包括以下几种操作：</p><p><strong>select lock in share mode（共享锁）</strong><br><strong>select for update（排他锁）</strong><br><strong>update（排他锁）</strong><br><strong>insert（排他锁）</strong><br><strong>delete（排他锁</strong>）</p></blockquote><h6 id="2-MVCC实现方式"><a href="#2-MVCC实现方式" class="headerlink" title="2.MVCC实现方式"></a>2.MVCC实现方式</h6><p>mvcc的实现，基于<strong>undolog</strong>、<strong>版本链</strong>、<strong>readview</strong>。</p><ol><li><h6 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a><strong>undolog</strong></h6></li></ol><p>mysql所对应的行记录除了我们自定义的字段之外，mysql会默认的添加一些隐藏字段，对于用户是不可见的</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5qjt4dj30uq0c6gni.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5qjt4dj30uq0c6gni.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208130805541"></p><ol start="2"><li><p><strong>readview</strong></p><blockquote><p>readview：表示事务进行快照读操作的时候产生的<strong>读视图</strong>，<strong>在该事务进行快照读的那一刻会生成一个系统当前的快照，但是此时的快照不是数据的快照，而是事务相关信息的快照</strong></p></blockquote><p><strong>基本参数:</strong></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5u7irjj30nu07u0tf.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5u7irjj30nu07u0tf.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208140115974"></p></li></ol><p><strong>readview算法</strong></p><blockquote><p>1、首先比较DB_TRX_ID &lt; up_limit_id,如果小于，则当前事务能看到DB_TRX_ID所在的记录，如果大于等于进入下一个判断</p><p>2、接下来判断DB_TRX_ID &gt;&#x3D; low_limit_id,如果大于等于则代表DB_TRX_ID所在的记录在Read View生成后才出现的，那么对于当前事务肯定不可见，如果小于，则进入下一步判断</p><p>3、判断DB_TRX_ID是否在活跃事务中，如果在，则代表在Read View生成时刻，这个事务还是活跃状态，还没有commit，修改的数据，当前事务也是看不到，如果不在，则说明这个事务在Read View生成之前就已经开始commit，那么修改的结果是能够看见的。</p></blockquote><p><strong>案例演示</strong></p><p><strong>案例1:</strong></p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5xkae0j30lo0fudgw.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi5xkae0j30lo0fudgw.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208140211649" style="zoom:67%;" /><p><strong>案例2:</strong></p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi61bhw9j30l20i83zq.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi61bhw9j30l20i83zq.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208140249833" style="zoom:67%;" /><p>分析:</p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi65nrmij30te0aoabc.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi65nrmij30te0aoabc.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208140320313" style="zoom:67%;" /><p>​              …</p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi6a957mj30v60aqwfu.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/008vxvgGgy1h8wi6a957mj30v60aqwfu.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221208140338601" style="zoom:67%;" /><blockquote><p>通过观察，可见性算法和readview的值都没有变，但是实验的结果却不同，所以在执行过程中肯定有些数据是发生变化的，可见性算法是固定死的，唯一可能变的就是readview，<br>大胆的做一个假设，假设橙色部分使用的readview并没有重新生成，而是沿用了绿色部分的readview，我们来验证实验的结果是啥？</p><p>经过分析发现跟我们的实验结果是保持一致的，那么就说明第二次在进行快照读的时候沿用了第一个的readview</p></blockquote><blockquote><p><strong>1.在RC隔离级别的时候，每一次进行快照读都会生成新的readview<br>2.在RR隔离级别的时候，只有在第一次进行快照读的时候才会生成readview，之后的快照读都会沿用之前的readview，不会重新生成</strong></p><p>**<br>3.两个隔离级别的区别点在与生成readview的时机不同**</p><p><strong>RR隔离级别解决了不可重复读的问题，RC隔离级别解决了幻读的问题</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何解决并发场景下扣款的数据一致性问题？</title>
      <link href="/2022/11/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%89%A3%E6%AC%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
      <url>/2022/11/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%89%A3%E6%AC%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、场景介绍"><a href="#1、场景介绍" class="headerlink" title="1、场景介绍"></a><strong>1、场景介绍</strong></h2><p>场景1：扣费，企业账户送流量或者红包，用户签到领取。此场景下就是多用户对某一个账号的并发扣款；</p><p>场景2：充值，打赏给主播，这种场景是多用户对同一个账号进行打款，但是方案和问题和场景1是一致的。</p><h2 id="2、场景举例"><a href="#2、场景举例" class="headerlink" title="2、场景举例"></a><strong>2、场景举例</strong></h2><p>假设有两个业务操作同一个账号，账号余额为100，业务1扣除50，业务2扣除40，如果顺利应该是剩余100-50-40&#x3D;10，那么我们看如下并发操作的场景：</p><p><img src="https://pic1.zhimg.com/80/v2-85e02a15fad5dfee63b2cb926459e6b0_1440w.webp" class="lazyload" data-srcset="https://pic1.zhimg.com/80/v2-85e02a15fad5dfee63b2cb926459e6b0_1440w.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>通过两个业务的并发操作，最后账户余额为60（是业务2最后修改后的余额值）。</p><h2 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a><strong>3、解决方案</strong></h2><p><strong>3.1 悲观锁</strong></p><h6 id="概念"><a href="#概念" class="headerlink" title="概念:"></a><strong>概念:</strong></h6><p>要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p><h6 id="悲观锁的实现"><a href="#悲观锁的实现" class="headerlink" title="悲观锁的实现"></a><strong>悲观锁的实现</strong></h6><blockquote><ol><li>传统的关系型数据库使用这种锁机制，比如<strong>行锁</strong>、<strong>表锁</strong>、<strong>读锁</strong>、<strong>写锁等</strong>，都是在操作之前先上锁。</li><li>Java 里面的同步 <strong>synchronized</strong>关键字的实现。</li></ol></blockquote><h6 id="悲观锁主要分为共享锁和排他锁"><a href="#悲观锁主要分为共享锁和排他锁" class="headerlink" title="悲观锁主要分为共享锁和排他锁"></a><strong>悲观锁主要分为共享锁和排他锁</strong></h6><ul><li><blockquote><p>共享锁【shared locks】又称为读锁，简称 S 锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p></blockquote></li><li><blockquote><p>排他锁【exclusive locks】又称为写锁，简称 X 锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。获取排他锁的事务可以对数据行读取和修改。</p></blockquote></li></ul><p>在查询语句加 for update，行记录加上排它锁，这样后来的事务会阻塞查询，这样就避免了数据不一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>开始事务</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>消费金额</span><br><span class="line">$spend <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询用户余额</span><br><span class="line">$<span class="keyword">user</span> <span class="operator">=</span> <span class="keyword">select</span> id,money <span class="keyword">from</span> t_account <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125; <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>计算金额</span><br><span class="line">$newMoney <span class="operator">=</span> $<span class="keyword">user</span>[<span class="string">&#x27;money&#x27;</span>]<span class="operator">-</span>$spend;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>.. 这里检查余额是否足够</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>更新余额</span><br><span class="line"><span class="keyword">update</span> t_account <span class="keyword">set</span> money <span class="operator">=</span> $newMoney <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;  ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>确认成功之后  提交事务</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure><p><strong>3.2 乐观锁</strong></p><h6 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h6><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于<strong>读多写少</strong>的场景，这样可以提高程序的吞吐量。</p><p>乐观锁采取了更加宽松的加锁机制。也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现：</p><blockquote><ol><li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li><li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</li></ol></blockquote><p>通过CAS操作，即旧值和预期值相同时执行修改，例如：</p><p><code>update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125;;</code></p><p>修改为：</p><p><code>Update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125; and money=#&#123;old_money&#125;;</code></p><p>这样在并发情况下，只能有一个修改成功，affect row为1；其他事务由于money不等于旧值，修改失败，affect row为0。</p><p><strong>3.3 为什么不使用减等于的sql操作</strong></p><p>例如 :</p><p><code>update t_account set money= money - $spend where id = #&#123;id&#125; ;</code></p><p>这里要再加上余额的判断避免出现负数金额：</p><p><code>Update t_account set money= money- $spend where id = #&#123;id&#125;&#125; and money&gt;= $spend ;</code></p><p>稍微改一下这里的更新语句也能完成正确的更新就算是并发也都将正常。</p><p>但是这样做将产生一个问题不幂等。</p><p><strong>什么是不幂等 ?</strong></p><p>在相同的条件下，执行同一请求，得到的结果相同才符合幂等性。</p><p>如果是money&#x3D; money- $spend的操作在多次操作场景下就会产生重复扣款。</p><p><strong>3.4 ABA问题</strong></p><p>ABA问题是由CAS衍生来的，在并发极端情况下会产生，那么什么是ABA问题？</p><p>标准的描述如下：</p><p>并发1（上）：获取出数据的初始值是A，后续计划实施CAS乐观锁，期望数据仍是A的时候，修改才能成功；</p><p>并发2：将数据修改成B；</p><p>并发3：将数据修改回A。</p><p>并发1（下）：CAS乐观锁，检测发现初始值还是A，进行数据修改。</p><p>上述并发环境下，并发1在修改数据时，虽然还是A，但已经不是初始条件的A了，中间发生了A变B，B又变A的变化，此A已经非彼A，数据却成功修改，可能导致错误，这就是CAS引发的所谓的ABA问题。</p><p>举一个游戏充值例子，如下：</p><p><img src="https://pic4.zhimg.com/80/v2-f82138c60a1dc5992b7c24efb05b3003_1440w.webp" class="lazyload" data-srcset="https://pic4.zhimg.com/80/v2-f82138c60a1dc5992b7c24efb05b3003_1440w.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>按照业务的诉求，事务3是最终将数据库结果值恢复为100，但是通过cas比较更新最终结果出现了40，这个就是ABA导致的问题。</p><p>我们还是以前面的sql作为例子讲解ABA问题如何解决？</p><p>1、数据库表结构由(id、money)修改为(id、money、version)</p><p>2、数据库查询由之前的：</p><p><code>select money from t_account where id=#&#123;id&#125;</code></p><p>修改为：</p><p><code>select money,version from t_account where id=$&#123;id&#125;</code></p><p>3、数据库修改除了cas比较外，还需要版本相同，并且进行版本修改：</p><p><code>update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125; and money=#&#123;old_money&#125;;</code></p><p>修改为：</p><p><code>update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125; and money=#&#123;old_money&#125; and version=#&#123;version_old&#125;</code></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a><strong>4、总结</strong></h2><p>select&amp;set业务场景，在并发时会出现一致性问题；</p><p>基于“值”的CAS乐观锁，可能导致ABA问题；</p><p>不能采用减等于的sql操作，由于此操作不幂等；</p><p>CAS乐观锁，必须保证修改时的“此数据”就是“彼数据”，应该由“值”比对，优化为“版本号”比对。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> mysql </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu服务器ssh配置并完成内网穿透</title>
      <link href="/2022/11/01/ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8ssh%E9%85%8D%E7%BD%AE%E5%B9%B6%E5%AE%8C%E6%88%90%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2022/11/01/ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8ssh%E9%85%8D%E7%BD%AE%E5%B9%B6%E5%AE%8C%E6%88%90%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="ubuntu服务器ssh配置并完成内网穿透"><a href="#ubuntu服务器ssh配置并完成内网穿透" class="headerlink" title="ubuntu服务器ssh配置并完成内网穿透"></a>ubuntu服务器ssh配置并完成内网穿透</h3><p>基本介绍:物理服务器已经安装ubuntu18.04.需要配置ssh实现内网登录,并且使用内网穿透实现公网远程访问.</p><p>注意:如果你只是想登陆别的机器的SSH只需要安装openssh-client(ubuntu有默认安装，如果没有则sudo apt-get install openssh-client)，如果要使本机开放SSH服务就需要安装openssh-server</p><h2 id="一、配置ssh实现内网登录"><a href="#一、配置ssh实现内网登录" class="headerlink" title="一、配置ssh实现内网登录:"></a>一、配置ssh实现内网登录:</h2><h3 id="1-安装ssh-server"><a href="#1-安装ssh-server" class="headerlink" title="1.安装ssh-server:"></a>1.安装ssh-server:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h3 id="2-启动ssh服务"><a href="#2-启动ssh服务" class="headerlink" title="2.启动ssh服务:"></a>2.启动ssh服务:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start或sudo service ssh start</span><br></pre></td></tr></table></figure><h3 id="3-设置允许远程root用户登录"><a href="#3-设置允许远程root用户登录" class="headerlink" title="3.设置允许远程root用户登录:"></a>3.设置允许远程root用户登录:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>搜索找到PermitRootLogin</p><p>加入配置</p><p>PermitRootLogin yes</p><h3 id="4-重启SSH服务："><a href="#4-重启SSH服务：" class="headerlink" title="4.重启SSH服务："></a>4.重启SSH服务：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh stop</span><br><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure><h3 id="5-登陆SSH"><a href="#5-登陆SSH" class="headerlink" title="5.登陆SSH"></a>5.登陆SSH</h3><p>同一局域网内其他机器可以输入命令实现访问,内网访问</p><p>ssh 服务器名字@内网ip<br><font color='red'><strong>注意:</strong></font>不知道服务器IP地址可输入ifconfig查看,如果找不到命令请先输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure><p>安装net-tools.</p><h2 id="二、内网穿透-实现公网访问"><a href="#二、内网穿透-实现公网访问" class="headerlink" title="二、内网穿透,实现公网访问"></a>二、内网穿透,实现公网访问</h2><p>介绍:上述方式已经实现同一局域网内对ubuntu服务器的访问,客户端一旦离开该局域网就会失去连接,如果想要实现在家里,咖啡厅或者其他地方随时随地对服务器访问该怎么办呢?在ipv4公网IP资源枯竭的情况下，运营商基本不会分配公网IP。而想要实现公网访问内网&#x2F;局域网，普遍是通过内网穿透来实现。<br>本文使用cpolar完成内网穿透，支持http&#x2F;https&#x2F;tcp协议，可免费使用，并且不限制流量。能够将本地端口映射到公网上，生成公网，实现外网任意地点远程访问内网。</p><h3 id="1-安装cpolar"><a href="#1-安装cpolar" class="headerlink" title="1.安装cpolar"></a>1.安装cpolar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span><br></pre></td></tr></table></figure><p>注意:如果没有curl请按照提示安装curl</p><h3 id="2-查看cpolar版本信息"><a href="#2-查看cpolar版本信息" class="headerlink" title="2.查看cpolar版本信息"></a>2.查看cpolar版本信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar version</span><br></pre></td></tr></table></figure><h3 id="3-注册登录cpolar获取Authtoken"><a href="#3-注册登录cpolar获取Authtoken" class="headerlink" title="3.注册登录cpolar获取Authtoken"></a>3.注册登录cpolar获取Authtoken</h3><p>复制你的token</p><p><img src="https://img-blog.csdnimg.cn/c145ff0a358a4d0085f6ffda66a7b4a4.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/c145ff0a358a4d0085f6ffda66a7b4a4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx(你的token)</span><br></pre></td></tr></table></figure><h3 id="4-向系统添加服务"><a href="#4-向系统添加服务" class="headerlink" title="4.向系统添加服务"></a>4.向系统添加服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> cpolar</span><br></pre></td></tr></table></figure><h3 id="5-启动cpolar服务"><a href="#5-启动cpolar服务" class="headerlink" title="5.启动cpolar服务"></a>5.启动cpolar服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><h3 id="6-查看服务状态"><a href="#6-查看服务状态" class="headerlink" title="6.查看服务状态"></a>6.查看服务状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status cpolar</span><br></pre></td></tr></table></figure><h3 id="7-开启穿透"><a href="#7-开启穿透" class="headerlink" title="7.开启穿透"></a>7.开启穿透</h3><p>要在端口80上启动HTTP隧道，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar http 80</span><br></pre></td></tr></table></figure><h3 id="8-获取ssh隧道的公网地址"><a href="#8-获取ssh隧道的公网地址" class="headerlink" title="8.获取ssh隧道的公网地址"></a>8.获取ssh隧道的公网地址</h3><p>登录cpolar web UI管理界面</p><p>在浏览器访问：<a href="http://localhost:9200/%EF%BC%8C%E8%BE%93%E5%85%A5%E6%89%80%E6%B3%A8%E5%86%8C%E7%9A%84cpolar%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%EF%BC%8C%E7%99%BB%E5%BD%95cpolar">http://localhost:9200/，输入所注册的cpolar账号密码，登录cpolar</a> web UI管理界面</p><p><img src="https://img-blog.csdnimg.cn/341908d3c1e14a56a6819f8ec7714994.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/341908d3c1e14a56a6819f8ec7714994.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"> </p><p>控制端电脑打开终端命令行，输入命令，远程ssh访问局域网内的ubuntu。</p><p>如cpolar已经将本地22端口映射到了xxxx端口，所以，ssh命令需要加-p参数，后面加公网隧道端口号(具体端口号在url的:后面)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh  -p XXXXX 用户名@1.tcp.vip.cpolar.cn（X为cpolar生成的端口号，用户名替换为主机用户名）</span><br></pre></td></tr></table></figure><p>在输入正确的命令后，Ubuntu会出现提示信息，询问是否确定连接该端口，并要求输入Ubuntu系统的密码，此时分别输入“yes”和ubunt系统密码即可。</p><p>注意:cpolar免费版24小时更新一次公网ip,记得修改命令里的ip参数.<a src='https://www.cpolar.com/docs'>详情见文档</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> ssh </category>
          
          <category> cploar </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swagger2入门</title>
      <link href="/2022/10/30/Swagger2/"/>
      <url>/2022/10/30/Swagger2/</url>
      
        <content type="html"><![CDATA[<h2 id="4-Swagger2"><a href="#4-Swagger2" class="headerlink" title="4. Swagger2"></a>4. Swagger2</h2><p><img src="https://avatars.githubusercontent.com/u/7658037?s=200&v=4" class="lazyload" data-srcset="https://avatars.githubusercontent.com/u/7658037?s=200&v=4" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="@swagger-api"></p><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><pre><code>Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。</code></pre><h3 id="4-2-为什么使用Swagger"><a href="#4-2-为什么使用Swagger" class="headerlink" title="4.2 为什么使用Swagger"></a>4.2 为什么使用Swagger</h3><pre><code>当下很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的 Rest API 文档将会极大的提高我们的工作效率。传统意义上的文档都是后端开发人员手动编写的，相信大家也都知道这种方式很难保证文档的及时性，这种文档久而久之也就会失去其参考意义，反而还会加大我们的沟通成本。而 Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们就来了解一下它的优点：</code></pre><p>1.代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。<br>2.跨语言性，支持 40 多种语言。<br>3.Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</p><h3 id="4-3-快速入门"><a href="#4-3-快速入门" class="headerlink" title="4.3 快速入门"></a>4.3 快速入门</h3><h4 id="4-3-1-引入依赖"><a href="#4-3-1-引入依赖" class="headerlink" title="4.3.1 引入依赖"></a>4.3.1 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-2-启用Swagger2"><a href="#4-3-2-启用Swagger2" class="headerlink" title="4.3.2 启用Swagger2"></a>4.3.2 启用Swagger2</h4><pre><code>在启动类上或者配置类加 @EnableSwagger2 注解</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.sangeng.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SanGengBlogApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SanGengBlogApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-测试"><a href="#4-3-3-测试" class="headerlink" title="4.3.3 测试"></a>4.3.3 测试</h4><pre><code>访问：http://localhost:7777/swagger-ui.html  注意其中localhost和7777要调整成实际项目的域名和端口号。</code></pre><h3 id="4-4-具体配置"><a href="#4-4-具体配置" class="headerlink" title="4.4 具体配置"></a>4.4 具体配置</h3><h4 id="4-4-1-Controller配置"><a href="#4-4-1-Controller配置" class="headerlink" title="4.4.1 Controller配置"></a>4.4.1 Controller配置</h4><h5 id="4-4-1-Api-注解"><a href="#4-4-1-Api-注解" class="headerlink" title="4.4.1 @Api 注解"></a>4.4.1 @Api 注解</h5><p>属性介绍：</p><p>tags  设置标签</p><p>description 设置描述信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/comment&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;评论&quot;,description = &quot;评论相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-接口配置"><a href="#4-4-2-接口配置" class="headerlink" title="4.4.2 接口配置"></a>4.4.2 接口配置</h4><h5 id="4-4-2-1-接口描述配置-ApiOperation"><a href="#4-4-2-1-接口描述配置-ApiOperation" class="headerlink" title="4.4.2.1 接口描述配置@ApiOperation"></a>4.4.2.1 接口描述配置@ApiOperation</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/linkCommentList&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;友链评论列表&quot;,notes = &quot;获取一页友链评论&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">linkCommentList</span><span class="params">(Integer pageNum,Integer pageSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commentService.commentList(SystemConstants.LINK_COMMENT,<span class="literal">null</span>,pageNum,pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-2-2-接口参数描述"><a href="#4-4-2-2-接口参数描述" class="headerlink" title="4.4.2.2 接口参数描述"></a>4.4.2.2 接口参数描述</h5><p> @ApiImplicitParam 用于描述接口的参数，但是一个接口可能有多个参数，所以一般与 @ApiImplicitParams 组合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/linkCommentList&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;友链评论列表&quot;,notes = &quot;获取一页友链评论&quot;)</span></span><br><span class="line"><span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">       @ApiImplicitParam(name = &quot;pageNum&quot;,value = &quot;页号&quot;),</span></span><br><span class="line"><span class="meta">       @ApiImplicitParam(name = &quot;pageSize&quot;,value = &quot;每页大小&quot;)</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">linkCommentList</span><span class="params">(Integer pageNum,Integer pageSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commentService.commentList(SystemConstants.LINK_COMMENT,<span class="literal">null</span>,pageNum,pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-实体类配置"><a href="#4-4-3-实体类配置" class="headerlink" title="4.4.3 实体类配置"></a>4.4.3 实体类配置</h4><h5 id="4-4-3-1-实体的描述配置-ApiModel"><a href="#4-4-3-1-实体的描述配置-ApiModel" class="headerlink" title="4.4.3.1 实体的描述配置@ApiModel"></a>4.4.3.1 实体的描述配置@ApiModel</h5><p>@ApiModel用于描述实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;添加评论dto&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCommentDto</span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-3-2-实体的属性的描述配置-ApiModelProperty"><a href="#4-4-3-2-实体的属性的描述配置-ApiModelProperty" class="headerlink" title="4.4.3.2 实体的属性的描述配置@ApiModelProperty"></a>4.4.3.2 实体的属性的描述配置@ApiModelProperty</h5><p>@ApiModelProperty用于描述实体的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(notes = &quot;评论类型（0代表文章评论，1代表友链评论）&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String type;</span><br></pre></td></tr></table></figure><h4 id="4-4-4-文档信息配置"><a href="#4-4-4-文档信息配置" class="headerlink" title="4.4.4 文档信息配置"></a>4.4.4 文档信息配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">customDocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sangeng.controller&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;团队名&quot;</span>, <span class="string">&quot;http://www.my.com&quot;</span>, <span class="string">&quot;my@my.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;文档标题&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;文档描述&quot;</span>)</span><br><span class="line">                .contact(contact)   <span class="comment">// 联系方式</span></span><br><span class="line">                .version(<span class="string">&quot;1.1.0&quot;</span>)  <span class="comment">// 版本</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
