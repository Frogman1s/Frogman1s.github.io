<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何解决并发场景下扣款的数据一致性问题？</title>
      <link href="/2022/11/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%89%A3%E6%AC%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
      <url>/2022/11/27/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%89%A3%E6%AC%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、场景介绍"><a href="#1、场景介绍" class="headerlink" title="1、场景介绍"></a><strong>1、场景介绍</strong></h2><p>场景1：扣费，企业账户送流量或者红包，用户签到领取。此场景下就是多用户对某一个账号的并发扣款；</p><p>场景2：充值，打赏给主播，这种场景是多用户对同一个账号进行打款，但是方案和问题和场景1是一致的。</p><h2 id="2、场景举例"><a href="#2、场景举例" class="headerlink" title="2、场景举例"></a><strong>2、场景举例</strong></h2><p>假设有两个业务操作同一个账号，账号余额为100，业务1扣除50，业务2扣除40，如果顺利应该是剩余100-50-40&#x3D;10，那么我们看如下并发操作的场景：</p><p><img src="https://pic1.zhimg.com/80/v2-85e02a15fad5dfee63b2cb926459e6b0_1440w.webp" class="lazyload" data-srcset="https://pic1.zhimg.com/80/v2-85e02a15fad5dfee63b2cb926459e6b0_1440w.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>通过两个业务的并发操作，最后账户余额为60（是业务2最后修改后的余额值）。</p><h2 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a><strong>3、解决方案</strong></h2><p><strong>3.1 悲观锁</strong></p><h6 id="概念"><a href="#概念" class="headerlink" title="概念:"></a><strong>概念:</strong></h6><p>要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p><h6 id="悲观锁的实现"><a href="#悲观锁的实现" class="headerlink" title="悲观锁的实现"></a><strong>悲观锁的实现</strong></h6><blockquote><ol><li>传统的关系型数据库使用这种锁机制，比如<strong>行锁</strong>、<strong>表锁</strong>、<strong>读锁</strong>、<strong>写锁等</strong>，都是在操作之前先上锁。</li><li>Java 里面的同步 <strong>synchronized</strong>关键字的实现。</li></ol></blockquote><h6 id="悲观锁主要分为共享锁和排他锁"><a href="#悲观锁主要分为共享锁和排他锁" class="headerlink" title="悲观锁主要分为共享锁和排他锁"></a><strong>悲观锁主要分为共享锁和排他锁</strong></h6><ul><li><blockquote><p>共享锁【shared locks】又称为读锁，简称 S 锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p></blockquote></li><li><blockquote><p>排他锁【exclusive locks】又称为写锁，简称 X 锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。获取排他锁的事务可以对数据行读取和修改。</p></blockquote></li></ul><p>在查询语句加 for update，行记录加上排它锁，这样后来的事务会阻塞查询，这样就避免了数据不一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>开始事务</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>消费金额</span><br><span class="line">$spend <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询用户余额</span><br><span class="line">$<span class="keyword">user</span> <span class="operator">=</span> <span class="keyword">select</span> id,money <span class="keyword">from</span> t_account <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125; <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>计算金额</span><br><span class="line">$newMoney <span class="operator">=</span> $<span class="keyword">user</span>[<span class="string">&#x27;money&#x27;</span>]<span class="operator">-</span>$spend;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>.. 这里检查余额是否足够</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>更新余额</span><br><span class="line"><span class="keyword">update</span> t_account <span class="keyword">set</span> money <span class="operator">=</span> $newMoney <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;  ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>确认成功之后  提交事务</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure><p><strong>3.2 乐观锁</strong></p><h6 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h6><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于<strong>读多写少</strong>的场景，这样可以提高程序的吞吐量。</p><p>乐观锁采取了更加宽松的加锁机制。也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现：</p><blockquote><ol><li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li><li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</li></ol></blockquote><p>通过CAS操作，即旧值和预期值相同时执行修改，例如：</p><p><code>update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125;;</code></p><p>修改为：</p><p><code>Update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125; and money=#&#123;old_money&#125;;</code></p><p>这样在并发情况下，只能有一个修改成功，affect row为1；其他事务由于money不等于旧值，修改失败，affect row为0。</p><p><strong>3.3 为什么不使用减等于的sql操作</strong></p><p>例如 :</p><p><code>update t_account set money= money - $spend where id = #&#123;id&#125; ;</code></p><p>这里要再加上余额的判断避免出现负数金额：</p><p><code>Update t_account set money= money- $spend where id = #&#123;id&#125;&#125; and money&gt;= $spend ;</code></p><p>稍微改一下这里的更新语句也能完成正确的更新就算是并发也都将正常。</p><p>但是这样做将产生一个问题不幂等。</p><p><strong>什么是不幂等 ?</strong></p><p>在相同的条件下，执行同一请求，得到的结果相同才符合幂等性。</p><p>如果是money&#x3D; money- $spend的操作在多次操作场景下就会产生重复扣款。</p><p><strong>3.4 ABA问题</strong></p><p>ABA问题是由CAS衍生来的，在并发极端情况下会产生，那么什么是ABA问题？</p><p>标准的描述如下：</p><p>并发1（上）：获取出数据的初始值是A，后续计划实施CAS乐观锁，期望数据仍是A的时候，修改才能成功；</p><p>并发2：将数据修改成B；</p><p>并发3：将数据修改回A。</p><p>并发1（下）：CAS乐观锁，检测发现初始值还是A，进行数据修改。</p><p>上述并发环境下，并发1在修改数据时，虽然还是A，但已经不是初始条件的A了，中间发生了A变B，B又变A的变化，此A已经非彼A，数据却成功修改，可能导致错误，这就是CAS引发的所谓的ABA问题。</p><p>举一个游戏充值例子，如下：</p><p><img src="https://pic4.zhimg.com/80/v2-f82138c60a1dc5992b7c24efb05b3003_1440w.webp" class="lazyload" data-srcset="https://pic4.zhimg.com/80/v2-f82138c60a1dc5992b7c24efb05b3003_1440w.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>按照业务的诉求，事务3是最终将数据库结果值恢复为100，但是通过cas比较更新最终结果出现了40，这个就是ABA导致的问题。</p><p>我们还是以前面的sql作为例子讲解ABA问题如何解决？</p><p>1、数据库表结构由(id、money)修改为(id、money、version)</p><p>2、数据库查询由之前的：</p><p><code>select money from t_account where id=#&#123;id&#125;</code></p><p>修改为：</p><p><code>select money,version from t_account where id=$&#123;id&#125;</code></p><p>3、数据库修改除了cas比较外，还需要版本相同，并且进行版本修改：</p><p><code>update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125; and money=#&#123;old_money&#125;;</code></p><p>修改为：</p><p><code>update t_account set money=#&#123;new_money&#125; where id=#&#123;id&#125; and money=#&#123;old_money&#125; and version=#&#123;version_old&#125;</code></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a><strong>4、总结</strong></h2><p>select&amp;set业务场景，在并发时会出现一致性问题；</p><p>基于“值”的CAS乐观锁，可能导致ABA问题；</p><p>不能采用减等于的sql操作，由于此操作不幂等；</p><p>CAS乐观锁，必须保证修改时的“此数据”就是“彼数据”，应该由“值”比对，优化为“版本号”比对。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> mysql </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu服务器ssh配置并完成内网穿透</title>
      <link href="/2022/11/01/ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8ssh%E9%85%8D%E7%BD%AE%E5%B9%B6%E5%AE%8C%E6%88%90%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2022/11/01/ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8ssh%E9%85%8D%E7%BD%AE%E5%B9%B6%E5%AE%8C%E6%88%90%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="ubuntu服务器ssh配置并完成内网穿透"><a href="#ubuntu服务器ssh配置并完成内网穿透" class="headerlink" title="ubuntu服务器ssh配置并完成内网穿透"></a>ubuntu服务器ssh配置并完成内网穿透</h3><p>基本介绍:物理服务器已经安装ubuntu18.04.需要配置ssh实现内网登录,并且使用内网穿透实现公网远程访问.</p><p>注意:如果你只是想登陆别的机器的SSH只需要安装openssh-client(ubuntu有默认安装，如果没有则sudo apt-get install openssh-client)，如果要使本机开放SSH服务就需要安装openssh-server</p><h2 id="一、配置ssh实现内网登录"><a href="#一、配置ssh实现内网登录" class="headerlink" title="一、配置ssh实现内网登录:"></a>一、配置ssh实现内网登录:</h2><h3 id="1-安装ssh-server"><a href="#1-安装ssh-server" class="headerlink" title="1.安装ssh-server:"></a>1.安装ssh-server:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h3 id="2-启动ssh服务"><a href="#2-启动ssh服务" class="headerlink" title="2.启动ssh服务:"></a>2.启动ssh服务:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start或sudo service ssh start</span><br></pre></td></tr></table></figure><h3 id="3-设置允许远程root用户登录"><a href="#3-设置允许远程root用户登录" class="headerlink" title="3.设置允许远程root用户登录:"></a>3.设置允许远程root用户登录:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>搜索找到PermitRootLogin</p><p>加入配置</p><p>PermitRootLogin yes</p><h3 id="4-重启SSH服务："><a href="#4-重启SSH服务：" class="headerlink" title="4.重启SSH服务："></a>4.重启SSH服务：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh stop</span><br><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure><h3 id="5-登陆SSH"><a href="#5-登陆SSH" class="headerlink" title="5.登陆SSH"></a>5.登陆SSH</h3><p>同一局域网内其他机器可以输入命令实现访问,内网访问</p><p>ssh 服务器名字@内网ip<br><font color='red'><strong>注意:</strong></font>不知道服务器IP地址可输入ifconfig查看,如果找不到命令请先输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure><p>安装net-tools.</p><h2 id="二、内网穿透-实现公网访问"><a href="#二、内网穿透-实现公网访问" class="headerlink" title="二、内网穿透,实现公网访问"></a>二、内网穿透,实现公网访问</h2><p>介绍:上述方式已经实现同一局域网内对ubuntu服务器的访问,客户端一旦离开该局域网就会失去连接,如果想要实现在家里,咖啡厅或者其他地方随时随地对服务器访问该怎么办呢?在ipv4公网IP资源枯竭的情况下，运营商基本不会分配公网IP。而想要实现公网访问内网&#x2F;局域网，普遍是通过内网穿透来实现。<br>本文使用cpolar完成内网穿透，支持http&#x2F;https&#x2F;tcp协议，可免费使用，并且不限制流量。能够将本地端口映射到公网上，生成公网，实现外网任意地点远程访问内网。</p><h3 id="1-安装cpolar"><a href="#1-安装cpolar" class="headerlink" title="1.安装cpolar"></a>1.安装cpolar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span><br></pre></td></tr></table></figure><p>注意:如果没有curl请按照提示安装curl</p><h3 id="2-查看cpolar版本信息"><a href="#2-查看cpolar版本信息" class="headerlink" title="2.查看cpolar版本信息"></a>2.查看cpolar版本信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar version</span><br></pre></td></tr></table></figure><h3 id="3-注册登录cpolar获取Authtoken"><a href="#3-注册登录cpolar获取Authtoken" class="headerlink" title="3.注册登录cpolar获取Authtoken"></a>3.注册登录cpolar获取Authtoken</h3><p>复制你的token</p><p><img src="https://img-blog.csdnimg.cn/c145ff0a358a4d0085f6ffda66a7b4a4.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/c145ff0a358a4d0085f6ffda66a7b4a4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx(你的token)</span><br></pre></td></tr></table></figure><h3 id="4-向系统添加服务"><a href="#4-向系统添加服务" class="headerlink" title="4.向系统添加服务"></a>4.向系统添加服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> cpolar</span><br></pre></td></tr></table></figure><h3 id="5-启动cpolar服务"><a href="#5-启动cpolar服务" class="headerlink" title="5.启动cpolar服务"></a>5.启动cpolar服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure><h3 id="6-查看服务状态"><a href="#6-查看服务状态" class="headerlink" title="6.查看服务状态"></a>6.查看服务状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status cpolar</span><br></pre></td></tr></table></figure><h3 id="7-开启穿透"><a href="#7-开启穿透" class="headerlink" title="7.开启穿透"></a>7.开启穿透</h3><p>要在端口80上启动HTTP隧道，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar http 80</span><br></pre></td></tr></table></figure><h3 id="8-获取ssh隧道的公网地址"><a href="#8-获取ssh隧道的公网地址" class="headerlink" title="8.获取ssh隧道的公网地址"></a>8.获取ssh隧道的公网地址</h3><p>登录cpolar web UI管理界面</p><p>在浏览器访问：<a href="http://localhost:9200/%EF%BC%8C%E8%BE%93%E5%85%A5%E6%89%80%E6%B3%A8%E5%86%8C%E7%9A%84cpolar%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%EF%BC%8C%E7%99%BB%E5%BD%95cpolar">http://localhost:9200/，输入所注册的cpolar账号密码，登录cpolar</a> web UI管理界面</p><p><img src="https://img-blog.csdnimg.cn/341908d3c1e14a56a6819f8ec7714994.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/341908d3c1e14a56a6819f8ec7714994.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"> </p><p>控制端电脑打开终端命令行，输入命令，远程ssh访问局域网内的ubuntu。</p><p>如cpolar已经将本地22端口映射到了xxxx端口，所以，ssh命令需要加-p参数，后面加公网隧道端口号(具体端口号在url的:后面)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh  -p XXXXX 用户名@1.tcp.vip.cpolar.cn（X为cpolar生成的端口号，用户名替换为主机用户名）</span><br></pre></td></tr></table></figure><p>在输入正确的命令后，Ubuntu会出现提示信息，询问是否确定连接该端口，并要求输入Ubuntu系统的密码，此时分别输入“yes”和ubunt系统密码即可。</p><p>注意:cpolar免费版24小时更新一次公网ip,记得修改命令里的ip参数.<a src='https://www.cpolar.com/docs'>详情见文档</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> ssh </category>
          
          <category> cploar </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swagger2入门</title>
      <link href="/2022/10/30/Swagger2/"/>
      <url>/2022/10/30/Swagger2/</url>
      
        <content type="html"><![CDATA[<h2 id="4-Swagger2"><a href="#4-Swagger2" class="headerlink" title="4. Swagger2"></a>4. Swagger2</h2><p><img src="https://avatars.githubusercontent.com/u/7658037?s=200&v=4" class="lazyload" data-srcset="https://avatars.githubusercontent.com/u/7658037?s=200&v=4" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="@swagger-api"></p><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><pre><code>Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。</code></pre><h3 id="4-2-为什么使用Swagger"><a href="#4-2-为什么使用Swagger" class="headerlink" title="4.2 为什么使用Swagger"></a>4.2 为什么使用Swagger</h3><pre><code>当下很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的 Rest API 文档将会极大的提高我们的工作效率。传统意义上的文档都是后端开发人员手动编写的，相信大家也都知道这种方式很难保证文档的及时性，这种文档久而久之也就会失去其参考意义，反而还会加大我们的沟通成本。而 Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们就来了解一下它的优点：</code></pre><p>1.代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。<br>2.跨语言性，支持 40 多种语言。<br>3.Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</p><h3 id="4-3-快速入门"><a href="#4-3-快速入门" class="headerlink" title="4.3 快速入门"></a>4.3 快速入门</h3><h4 id="4-3-1-引入依赖"><a href="#4-3-1-引入依赖" class="headerlink" title="4.3.1 引入依赖"></a>4.3.1 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-2-启用Swagger2"><a href="#4-3-2-启用Swagger2" class="headerlink" title="4.3.2 启用Swagger2"></a>4.3.2 启用Swagger2</h4><pre><code>在启动类上或者配置类加 @EnableSwagger2 注解</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.sangeng.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SanGengBlogApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SanGengBlogApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-测试"><a href="#4-3-3-测试" class="headerlink" title="4.3.3 测试"></a>4.3.3 测试</h4><pre><code>访问：http://localhost:7777/swagger-ui.html  注意其中localhost和7777要调整成实际项目的域名和端口号。</code></pre><h3 id="4-4-具体配置"><a href="#4-4-具体配置" class="headerlink" title="4.4 具体配置"></a>4.4 具体配置</h3><h4 id="4-4-1-Controller配置"><a href="#4-4-1-Controller配置" class="headerlink" title="4.4.1 Controller配置"></a>4.4.1 Controller配置</h4><h5 id="4-4-1-Api-注解"><a href="#4-4-1-Api-注解" class="headerlink" title="4.4.1 @Api 注解"></a>4.4.1 @Api 注解</h5><p>属性介绍：</p><p>tags  设置标签</p><p>description 设置描述信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/comment&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;评论&quot;,description = &quot;评论相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-接口配置"><a href="#4-4-2-接口配置" class="headerlink" title="4.4.2 接口配置"></a>4.4.2 接口配置</h4><h5 id="4-4-2-1-接口描述配置-ApiOperation"><a href="#4-4-2-1-接口描述配置-ApiOperation" class="headerlink" title="4.4.2.1 接口描述配置@ApiOperation"></a>4.4.2.1 接口描述配置@ApiOperation</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/linkCommentList&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;友链评论列表&quot;,notes = &quot;获取一页友链评论&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">linkCommentList</span><span class="params">(Integer pageNum,Integer pageSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commentService.commentList(SystemConstants.LINK_COMMENT,<span class="literal">null</span>,pageNum,pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-2-2-接口参数描述"><a href="#4-4-2-2-接口参数描述" class="headerlink" title="4.4.2.2 接口参数描述"></a>4.4.2.2 接口参数描述</h5><p> @ApiImplicitParam 用于描述接口的参数，但是一个接口可能有多个参数，所以一般与 @ApiImplicitParams 组合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/linkCommentList&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;友链评论列表&quot;,notes = &quot;获取一页友链评论&quot;)</span></span><br><span class="line"><span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">       @ApiImplicitParam(name = &quot;pageNum&quot;,value = &quot;页号&quot;),</span></span><br><span class="line"><span class="meta">       @ApiImplicitParam(name = &quot;pageSize&quot;,value = &quot;每页大小&quot;)</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">linkCommentList</span><span class="params">(Integer pageNum,Integer pageSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commentService.commentList(SystemConstants.LINK_COMMENT,<span class="literal">null</span>,pageNum,pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-实体类配置"><a href="#4-4-3-实体类配置" class="headerlink" title="4.4.3 实体类配置"></a>4.4.3 实体类配置</h4><h5 id="4-4-3-1-实体的描述配置-ApiModel"><a href="#4-4-3-1-实体的描述配置-ApiModel" class="headerlink" title="4.4.3.1 实体的描述配置@ApiModel"></a>4.4.3.1 实体的描述配置@ApiModel</h5><p>@ApiModel用于描述实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;添加评论dto&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCommentDto</span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-3-2-实体的属性的描述配置-ApiModelProperty"><a href="#4-4-3-2-实体的属性的描述配置-ApiModelProperty" class="headerlink" title="4.4.3.2 实体的属性的描述配置@ApiModelProperty"></a>4.4.3.2 实体的属性的描述配置@ApiModelProperty</h5><p>@ApiModelProperty用于描述实体的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(notes = &quot;评论类型（0代表文章评论，1代表友链评论）&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String type;</span><br></pre></td></tr></table></figure><h4 id="4-4-4-文档信息配置"><a href="#4-4-4-文档信息配置" class="headerlink" title="4.4.4 文档信息配置"></a>4.4.4 文档信息配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">customDocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sangeng.controller&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;团队名&quot;</span>, <span class="string">&quot;http://www.my.com&quot;</span>, <span class="string">&quot;my@my.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;文档标题&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;文档描述&quot;</span>)</span><br><span class="line">                .contact(contact)   <span class="comment">// 联系方式</span></span><br><span class="line">                .version(<span class="string">&quot;1.1.0&quot;</span>)  <span class="comment">// 版本</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
